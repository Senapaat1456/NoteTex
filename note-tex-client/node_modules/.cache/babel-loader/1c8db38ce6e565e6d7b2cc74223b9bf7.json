{"ast":null,"code":"import { checkForErrors } from './UserActions';\nexport const LineAction = Object.freeze({\n  StartEdit: 'StartEdit',\n  EndEdit: 'EndEdit',\n  LoadLine: 'LoadLine',\n  IncrementLineCount: 'IncrementLineCount',\n  AddNewLine: 'AddNewLine',\n  RemoveLine: 'removeLine'\n});\nconst host = 'http://websystems.senapatiratne.com:1443';\nexport function startEdit(lineNumber) {\n  return {\n    type: LineAction.StartEdit,\n    payload: lineNumber\n  };\n}\nexport function beginEndEdit(noteLine, noteLines, currentLineCount, currentNoteSheet_id, currentUserName) {\n  if (currentUserName == null || currentUserName === \"\") {\n    return dispatch => {\n      dispatch(finishEndEdit(noteLine));\n    };\n  } else {\n    const combinedContents = noteLines.map(line => {\n      if (line.lineNumber === noteLine.lineNumber) {\n        return noteLine;\n      } else {\n        return line;\n      }\n    });\n    return dispatch => {\n      dispatch(finishEndEdit(noteLine)); //I know this is out of order, the reason being, if the user has to wait for the server before continuing writing, it can ruin the flow, so its more important to let the user keep working then to make sure the server is perfectly sinked\n\n      fetch(`${host}/noteSheetEdit`, options).then(checkForErrors);\n    };\n  }\n}\nexport function finishEndEdit(noteLine, noteLines, currentLineCount, currentNoteSheet_id, currentUserName) {\n  return {\n    type: LineAction.EndEdit,\n    payload: noteLine\n  };\n}\nexport function addNewLine(location) {\n  return {\n    type: LineAction.AddNewLine,\n    payload: location\n  };\n}\nexport function loadLine(noteLine) {\n  return {\n    type: LineAction.LoadLine,\n    payload: noteLine\n  };\n}\nexport function incrementLineCount() {\n  return {\n    type: LineAction.IncrementLineCount,\n    payload: null\n  };\n}\nexport function removeLine(noteLine) {\n  return {\n    type: LineAction.RemoveLine,\n    payload: noteLine\n  };\n}","map":{"version":3,"sources":["/home/andrew/School/Spring_2020/WebSystems/NoteTex/note-tex-client/src/LineActions.js"],"names":["checkForErrors","LineAction","Object","freeze","StartEdit","EndEdit","LoadLine","IncrementLineCount","AddNewLine","RemoveLine","host","startEdit","lineNumber","type","payload","beginEndEdit","noteLine","noteLines","currentLineCount","currentNoteSheet_id","currentUserName","dispatch","finishEndEdit","combinedContents","map","line","fetch","options","then","addNewLine","location","loadLine","incrementLineCount","removeLine"],"mappings":"AAAA,SAAQA,cAAR,QAA6B,eAA7B;AAEA,OAAO,MAAMC,UAAU,GAAGC,MAAM,CAACC,MAAP,CAAc;AACtCC,EAAAA,SAAS,EAAE,WAD2B;AAEtCC,EAAAA,OAAO,EAAE,SAF6B;AAGtCC,EAAAA,QAAQ,EAAE,UAH4B;AAItCC,EAAAA,kBAAkB,EAAE,oBAJkB;AAKtCC,EAAAA,UAAU,EAAC,YAL2B;AAMtCC,EAAAA,UAAU,EAAC;AAN2B,CAAd,CAAnB;AASP,MAAMC,IAAI,GAAG,0CAAb;AAGA,OAAO,SAASC,SAAT,CAAmBC,UAAnB,EAA8B;AACnC,SAAM;AACJC,IAAAA,IAAI,EAAEZ,UAAU,CAACG,SADb;AAEJU,IAAAA,OAAO,EAAEF;AAFL,GAAN;AAID;AAED,OAAO,SAASG,YAAT,CAAsBC,QAAtB,EAAgCC,SAAhC,EAA2CC,gBAA3C,EAA6DC,mBAA7D,EAAiFC,eAAjF,EAAiG;AACtG,MAAGA,eAAe,IAAE,IAAjB,IAAyBA,eAAe,KAAG,EAA9C,EAAiD;AAC/C,WAAOC,QAAQ,IAAI;AACjBA,MAAAA,QAAQ,CAACC,aAAa,CAACN,QAAD,CAAd,CAAR;AACD,KAFD;AAGD,GAJD,MAIK;AACD,UAAMO,gBAAgB,GAAGN,SAAS,CAACO,GAAV,CAAcC,IAAI,IAAG;AAC5C,UAAGA,IAAI,CAACb,UAAL,KAAoBI,QAAQ,CAACJ,UAAhC,EAA2C;AACzC,eAAOI,QAAP;AACD,OAFD,MAGI;AACF,eAAOS,IAAP;AACD;AACF,KAPwB,CAAzB;AAQA,WAAOJ,QAAQ,IAAI;AACjBA,MAAAA,QAAQ,CAACC,aAAa,CAACN,QAAD,CAAd,CAAR,CADiB,CACiB;;AAClCU,MAAAA,KAAK,CAAE,GAAEhB,IAAK,gBAAT,EAAyBiB,OAAzB,CAAL,CACGC,IADH,CACQ5B,cADR;AAGD,KALD;AAMD;AACJ;AAID,OAAO,SAASsB,aAAT,CAAuBN,QAAvB,EAAiCC,SAAjC,EAA4CC,gBAA5C,EAA8DC,mBAA9D,EAAkFC,eAAlF,EAAkG;AACvG,SAAM;AACJP,IAAAA,IAAI,EAAEZ,UAAU,CAACI,OADb;AAEJS,IAAAA,OAAO,EAAEE;AAFL,GAAN;AAID;AAED,OAAO,SAASa,UAAT,CAAoBC,QAApB,EAA6B;AAChC,SAAM;AACNjB,IAAAA,IAAI,EAAEZ,UAAU,CAACO,UADX;AAENM,IAAAA,OAAO,EAAEgB;AAFH,GAAN;AAIH;AAED,OAAO,SAASC,QAAT,CAAkBf,QAAlB,EAA2B;AAChC,SAAO;AACLH,IAAAA,IAAI,EAAEZ,UAAU,CAACK,QADZ;AAELQ,IAAAA,OAAO,EAAEE;AAFJ,GAAP;AAID;AAED,OAAO,SAASgB,kBAAT,GAA6B;AAClC,SAAM;AACJnB,IAAAA,IAAI,EAAEZ,UAAU,CAACM,kBADb;AAEJO,IAAAA,OAAO,EAAE;AAFL,GAAN;AAID;AAED,OAAO,SAASmB,UAAT,CAAoBjB,QAApB,EAA6B;AAClC,SAAM;AACJH,IAAAA,IAAI,EAAEZ,UAAU,CAACQ,UADb;AAEJK,IAAAA,OAAO,EAAEE;AAFL,GAAN;AAID","sourcesContent":["import {checkForErrors} from './UserActions'\n\nexport const LineAction = Object.freeze({\n  StartEdit: 'StartEdit',\n  EndEdit: 'EndEdit',\n  LoadLine: 'LoadLine',\n  IncrementLineCount: 'IncrementLineCount',\n  AddNewLine:'AddNewLine',\n  RemoveLine:'removeLine'\n})\n\nconst host = 'http://websystems.senapatiratne.com:1443';\n\n\nexport function startEdit(lineNumber){\n  return{\n    type: LineAction.StartEdit,\n    payload: lineNumber\n  };\n}\n\nexport function beginEndEdit(noteLine, noteLines, currentLineCount, currentNoteSheet_id,currentUserName){\n  if(currentUserName==null || currentUserName===\"\"){\n    return dispatch => {\n      dispatch(finishEndEdit(noteLine))\n    }\n  }else{\n      const combinedContents = noteLines.map(line =>{\n        if(line.lineNumber === noteLine.lineNumber){\n          return noteLine;\n        }\n        else{\n          return line;\n        }\n      });\n      return dispatch => {\n        dispatch(finishEndEdit(noteLine)) //I know this is out of order, the reason being, if the user has to wait for the server before continuing writing, it can ruin the flow, so its more important to let the user keep working then to make sure the server is perfectly sinked\n        fetch(`${host}/noteSheetEdit`,options)\n          .then(checkForErrors)\n\n      };\n    }\n}\n\n\n\nexport function finishEndEdit(noteLine, noteLines, currentLineCount, currentNoteSheet_id,currentUserName){\n  return{\n    type: LineAction.EndEdit,\n    payload: noteLine,\n  };\n}\n\nexport function addNewLine(location){\n    return{\n    type: LineAction.AddNewLine,\n    payload: location,\n  }\n}\n\nexport function loadLine(noteLine){\n  return {\n    type: LineAction.LoadLine,\n    payload: noteLine,\n  };\n}\n\nexport function incrementLineCount(){\n  return{\n    type: LineAction.IncrementLineCount,\n    payload: null\n  }\n}\n\nexport function removeLine(noteLine){\n  return{\n    type: LineAction.RemoveLine,\n    payload: noteLine\n  }\n}\n"]},"metadata":{},"sourceType":"module"}