{"ast":null,"code":"import{checkForErrors}from'./UserActions';export var LineAction=Object.freeze({StartEdit:'StartEdit',EndEdit:'EndEdit',LoadLine:'LoadLine',IncrementLineCount:'IncrementLineCount',AddNewLine:'AddNewLine',RemoveLine:'removeLine'});var host='http://websystems.senapatiratne.com:1443';export function startEdit(lineNumber){return{type:LineAction.StartEdit,payload:lineNumber};}export function beginEndEdit(noteLine,noteLines,currentLineCount,currentNoteSheet_id,currentUserName){if(currentUserName==null||currentUserName===\"\"){return function(dispatch){dispatch(finishEndEdit(noteLine));};}else{var combinedContents=noteLines.map(function(line){if(line.lineNumber===noteLine.lineNumber){return noteLine;}else{return line;}});var newBody={contents:JSON.stringify(combinedContents),lineCount:currentLineCount,noteSheet_id:currentNoteSheet_id,userName:currentUserName};var options={method:'PATCH',headers:{'Content-Type':'application/json'},body:JSON.stringify(newBody)};return function(dispatch){dispatch(finishEndEdit(noteLine));//I know this is out of order, the reason being, if the user has to wait for the server before continuing writing, it can ruin the flow, so its more important to let the user keep working then to make sure the server is perfectly sinked\nfetch(\"\".concat(host,\"/noteSheetEdit\"),options).then(checkForErrors);};}}export function finishEndEdit(noteLine,noteLines,currentLineCount,currentNoteSheet_id,currentUserName){return{type:LineAction.EndEdit,payload:noteLine};}export function addNewLine(location){return{type:LineAction.AddNewLine,payload:location};}export function loadLine(noteLine){return{type:LineAction.LoadLine,payload:noteLine};}export function incrementLineCount(){return{type:LineAction.IncrementLineCount,payload:null};}export function removeLine(noteLine){return{type:LineAction.RemoveLine,payload:noteLine};}","map":{"version":3,"sources":["/home/andrew/School/Spring_2020/WebSystems/NoteTex/note-tex-client/src/LineActions.js"],"names":["checkForErrors","LineAction","Object","freeze","StartEdit","EndEdit","LoadLine","IncrementLineCount","AddNewLine","RemoveLine","host","startEdit","lineNumber","type","payload","beginEndEdit","noteLine","noteLines","currentLineCount","currentNoteSheet_id","currentUserName","dispatch","finishEndEdit","combinedContents","map","line","newBody","contents","JSON","stringify","lineCount","noteSheet_id","userName","options","method","headers","body","fetch","then","addNewLine","location","loadLine","incrementLineCount","removeLine"],"mappings":"AAAA,OAAQA,cAAR,KAA6B,eAA7B,CAEA,MAAO,IAAMC,CAAAA,UAAU,CAAGC,MAAM,CAACC,MAAP,CAAc,CACtCC,SAAS,CAAE,WAD2B,CAEtCC,OAAO,CAAE,SAF6B,CAGtCC,QAAQ,CAAE,UAH4B,CAItCC,kBAAkB,CAAE,oBAJkB,CAKtCC,UAAU,CAAC,YAL2B,CAMtCC,UAAU,CAAC,YAN2B,CAAd,CAAnB,CASP,GAAMC,CAAAA,IAAI,CAAG,0CAAb,CAGA,MAAO,SAASC,CAAAA,SAAT,CAAmBC,UAAnB,CAA8B,CACnC,MAAM,CACJC,IAAI,CAAEZ,UAAU,CAACG,SADb,CAEJU,OAAO,CAAEF,UAFL,CAAN,CAID,CAED,MAAO,SAASG,CAAAA,YAAT,CAAsBC,QAAtB,CAAgCC,SAAhC,CAA2CC,gBAA3C,CAA6DC,mBAA7D,CAAiFC,eAAjF,CAAiG,CACtG,GAAGA,eAAe,EAAE,IAAjB,EAAyBA,eAAe,GAAG,EAA9C,CAAiD,CAC/C,MAAO,UAAAC,QAAQ,CAAI,CACjBA,QAAQ,CAACC,aAAa,CAACN,QAAD,CAAd,CAAR,CACD,CAFD,CAGD,CAJD,IAIK,CACD,GAAMO,CAAAA,gBAAgB,CAAGN,SAAS,CAACO,GAAV,CAAc,SAAAC,IAAI,CAAG,CAC5C,GAAGA,IAAI,CAACb,UAAL,GAAoBI,QAAQ,CAACJ,UAAhC,CAA2C,CACzC,MAAOI,CAAAA,QAAP,CACD,CAFD,IAGI,CACF,MAAOS,CAAAA,IAAP,CACD,CACF,CAPwB,CAAzB,CAQA,GAAMC,CAAAA,OAAO,CAAG,CAACC,QAAQ,CAACC,IAAI,CAACC,SAAL,CAAeN,gBAAf,CAAV,CAA2CO,SAAS,CAACZ,gBAArD,CAAsEa,YAAY,CAACZ,mBAAnF,CAAuGa,QAAQ,CAACZ,eAAhH,CAAhB,CACA,GAAMa,CAAAA,OAAO,CAAG,CAACC,MAAM,CAAE,OAAT,CAAkBC,OAAO,CAAC,CAAC,eAAgB,kBAAjB,CAA1B,CAAgEC,IAAI,CAACR,IAAI,CAACC,SAAL,CAAeH,OAAf,CAArE,CAAhB,CACA,MAAO,UAAAL,QAAQ,CAAI,CACjBA,QAAQ,CAACC,aAAa,CAACN,QAAD,CAAd,CAAR,CAAkC;AAClCqB,KAAK,WAAI3B,IAAJ,mBAAyBuB,OAAzB,CAAL,CACGK,IADH,CACQtC,cADR,EAGD,CALD,CAMD,CACJ,CAID,MAAO,SAASsB,CAAAA,aAAT,CAAuBN,QAAvB,CAAiCC,SAAjC,CAA4CC,gBAA5C,CAA8DC,mBAA9D,CAAkFC,eAAlF,CAAkG,CACvG,MAAM,CACJP,IAAI,CAAEZ,UAAU,CAACI,OADb,CAEJS,OAAO,CAAEE,QAFL,CAAN,CAID,CAED,MAAO,SAASuB,CAAAA,UAAT,CAAoBC,QAApB,CAA6B,CAChC,MAAM,CACN3B,IAAI,CAAEZ,UAAU,CAACO,UADX,CAENM,OAAO,CAAE0B,QAFH,CAAN,CAIH,CAED,MAAO,SAASC,CAAAA,QAAT,CAAkBzB,QAAlB,CAA2B,CAChC,MAAO,CACLH,IAAI,CAAEZ,UAAU,CAACK,QADZ,CAELQ,OAAO,CAAEE,QAFJ,CAAP,CAID,CAED,MAAO,SAAS0B,CAAAA,kBAAT,EAA6B,CAClC,MAAM,CACJ7B,IAAI,CAAEZ,UAAU,CAACM,kBADb,CAEJO,OAAO,CAAE,IAFL,CAAN,CAID,CAED,MAAO,SAAS6B,CAAAA,UAAT,CAAoB3B,QAApB,CAA6B,CAClC,MAAM,CACJH,IAAI,CAAEZ,UAAU,CAACQ,UADb,CAEJK,OAAO,CAAEE,QAFL,CAAN,CAID","sourcesContent":["import {checkForErrors} from './UserActions'\n\nexport const LineAction = Object.freeze({\n  StartEdit: 'StartEdit',\n  EndEdit: 'EndEdit',\n  LoadLine: 'LoadLine',\n  IncrementLineCount: 'IncrementLineCount',\n  AddNewLine:'AddNewLine',\n  RemoveLine:'removeLine'\n})\n\nconst host = 'http://websystems.senapatiratne.com:1443';\n\n\nexport function startEdit(lineNumber){\n  return{\n    type: LineAction.StartEdit,\n    payload: lineNumber\n  };\n}\n\nexport function beginEndEdit(noteLine, noteLines, currentLineCount, currentNoteSheet_id,currentUserName){\n  if(currentUserName==null || currentUserName===\"\"){\n    return dispatch => {\n      dispatch(finishEndEdit(noteLine))\n    }\n  }else{\n      const combinedContents = noteLines.map(line =>{\n        if(line.lineNumber === noteLine.lineNumber){\n          return noteLine;\n        }\n        else{\n          return line;\n        }\n      });\n      const newBody = {contents:JSON.stringify(combinedContents),lineCount:currentLineCount,noteSheet_id:currentNoteSheet_id,userName:currentUserName};\n      const options = {method: 'PATCH', headers:{'Content-Type': 'application/json'}, body:JSON.stringify(newBody)};\n      return dispatch => {\n        dispatch(finishEndEdit(noteLine)) //I know this is out of order, the reason being, if the user has to wait for the server before continuing writing, it can ruin the flow, so its more important to let the user keep working then to make sure the server is perfectly sinked\n        fetch(`${host}/noteSheetEdit`,options)\n          .then(checkForErrors)\n\n      };\n    }\n}\n\n\n\nexport function finishEndEdit(noteLine, noteLines, currentLineCount, currentNoteSheet_id,currentUserName){\n  return{\n    type: LineAction.EndEdit,\n    payload: noteLine,\n  };\n}\n\nexport function addNewLine(location){\n    return{\n    type: LineAction.AddNewLine,\n    payload: location,\n  }\n}\n\nexport function loadLine(noteLine){\n  return {\n    type: LineAction.LoadLine,\n    payload: noteLine,\n  };\n}\n\nexport function incrementLineCount(){\n  return{\n    type: LineAction.IncrementLineCount,\n    payload: null\n  }\n}\n\nexport function removeLine(noteLine){\n  return{\n    type: LineAction.RemoveLine,\n    payload: noteLine\n  }\n}\n"]},"metadata":{},"sourceType":"module"}